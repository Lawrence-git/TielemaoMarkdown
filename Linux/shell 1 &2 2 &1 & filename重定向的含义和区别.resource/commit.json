{"compress":true,"commitItems":[["afbc9b0d-cd6f-4bb3-8f51-86116a30c147",1534402606805,"# shell 1>&2 2>&1 &>filename重定向的含义和区别\n\n_转载_  更新时间：2015年04月15日 22:07:32   投稿：mdxy-dxy   [![](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/64183.htm#comments)\n\n这篇文章主要介绍了shell 1>&2 2>&1 &>filename重定向的含义和区别,需要的朋友可以参考下\n\n当初在shell中, 看到\">&1\"和\">&2\"始终不明白什么意思.经过在网上的搜索得以解惑.其实这是两种输出.\n\n在 shell 程式中，最常使用的 FD (file descriptor) 大概有三个, 分别是:\n\n**0 是一个文件描述符，表示标准输入(stdin)**\n**1 **是一个文件描述符，**表示标准输出(stdout)**\n\n**2 **是一个文件描述符，**表示标准错误(stderr)**\n\n在标准情况下, 这些FD分别跟如下设备关联:\nstdin(0): keyboard 键盘输入,并返回在前端\nstdout(1): monitor 正确返回值 输出到前端\nstderr(2): monitor 错误返回值 输出到前端\n\n**举例说明吧:**\n\n当前目录只有一个文件 a.txt.\n[root@redhat box]# ls\na.txt\n[root@redhat box]# ls a.txt b.txt\nls: b.txt: No such file or directory 由于没有b.txt这个文件, 于是返回错误值, 这就是所谓的2输出\na.txt 而这个就是所谓的1输出\n\n**再接着看:**\n\n[root@redhat box]# ls a.txt b.txt 1>file.out 2>file.err\n执行后,没有任何返回值. 原因是, 返回值都重定向到相应的文件中了,而不再前端显示\n[root@redhat box]# cat file.out\na.txt\n[root@redhat box]# cat file.err\nls: b.txt: No such file or directory\n一般来说, \"1>\" 通常可以省略成 \">\".\n即可以把如上命令写成: ls a.txt b.txt >file.out 2>file.err\n有了这些认识才能理解 \"1>&2\" 和 \"2>&1\".\n1>&2 正确返回值传递给2输出通道 &2表示2输出通道\n如果此处错写成 1>2, 就表示把1输出重定向到文件2中.\n2>&1 错误返回值传递给1输出通道, 同样&1表示1输出通道.\n举个例子.\n[root@redhat box]# ls a.txt b.txt 1>file.out 2>&1\n[root@redhat box]# cat file.out\nls: b.txt: No such file or directory\na.txt\n现在, 正确的输出和错误的输出都定向到了file.out这个文件中, 而不显示在前端.\n补充下, 输出不只1和2, 还有其他的类型, 这两种只是最常用和最基本的.\n\n **>是重定向符，就是把前面输出的内容重定向到后面指定的位置，比如（例1）：**\n\necho \"一些内容\" > filename.txt\n\n上面例子会把 \"**一些****内容**\" 写入到 **filename.txt** 文件中。\n\n**>**前是可以加数字来说明把什么内容重定向到文件中，默认是把标准输出重定向到文件中，所以下面这个例子和上面那个是一样的（例2）：\n\necho \"一些内容\" 1> filename.txt\n\n如果是错误信息就不会输出到filename.txt（例3）：\n\n$ ls nodir 1> filename.txt\n$ ls: nodir: No such file or directory\n\n上面这个例子中nodir不存在，所以通过ls命令查询时错误信息会输出到 2(stderr)，但我们指定的是把1重定向到filename.txt，所以上面命令执行完后，filename.txt中是没有内容的。但是执行下面命令就会把错误信息写入到filename.txt中（例4）：\n\n$ ls nodir 2> filename.txt\n$ cat filename.txt\n$ ls: nodir: No such file or directory\n\n**& 是一个描述符，如果1或2前不加&，会被当成一个普通文件。**\n\n**1>&2 意思是把标准****输出重定向到标准****错误****.**\n\n**2>&1 意思是把标准错误输出重定向到标准输出。**\n\n**&>filename 意思是把标准输出和标准错误输出都重定向到文件filename****中**\n\n我们再看一个例子（列5）：\n\n$ ls nodir 1> filename.txt 2>&1\n$ cat filename.txt\n$ ls: nodir: No such file or directory\n\n上面例子把 **标准输出** 重定向到文件 **filename.txt**，然后把 **标准错误** 重定向到 **标准输出**，所以最后的错误信息也通过标准输出写入到了文件中，比较例3，4，5，就能明白其作用。\n\n下面是来自百度知道的内容，大家可以参考下：\n\n问：Linux重定向中 >&2 怎么理解？\n问题补充：echo \"aaaaaaaaaaaaaaaa\" >&2 怎么理解？\n\n答：\n\n>&2 即 1>&2 也就是把结果输出到和标准错误一样；之前如果有定义标准错误重定向到某log文件，那么标准输出也重定向到这个log文件\n如：ls 2>a1 >&2 （等同 ls >a1 2>&1）\n把标准输出和标准错误都重定向到a1，终端上看不到任何信息。",[[1534402587431,["Administrator@Tielemao",[[-1,39,"_转载_  更新时间：2015年04月15日 22:07:32   投稿：mdxy-dxy   [![](https://www.jb51.net/skin/2018/images/text-message.png) 我要评论](https://www.jb51.net/article/64183.htm#comments)\n\n"]],[38,203],[38,38]]],[1534402599319,["Administrator@Tielemao",[[1,39,"\n"]],[38,38],[39,39]]],[1534402601095,["Administrator@Tielemao",[[1,38,"https://www.jb51.net/article/64183.htm"]],[38,38],[76,76]]],[1534402601878,["Administrator@Tielemao",[[1,78,"\n"]],[76,76],[77,77]]],[1534402602401,["Administrator@Tielemao",[[1,38,"\n"]],[37,37],[38,38]]]],null,"Administrator@Tielemao"]]}