{"compress":true,"commitItems":[["ffd2a694-ef68-495a-a33d-7bcd1fbcb105",1533976491479,"MySQL\n\n\tchar与varchar区别：\n\t\tchar是定长，varchar是变长\n\t\t1.char是根据给出的限定长度来占字符，例如：给限定长度是4，如果你存一个字符，那也是按4个算，如果超出也是按4个算\n\t\tvarchar相反，如果是存一个字符，那就是按两个/三个字符算，如果存100个是按5/6个字符算\n\t\t2.如果取值时char末尾有空格会忽略，varchar会保留\n\t\t\nDjango\n\n\tDjango 的生命周期？\n\t用户输入URL之后，第一步wsgi模块接受请求，下一步交给中间节做处理，处理结束之后交给URL路由系统做视图分配工作，由视图和数据库取数据，然后调用模板返回给中间节--》wsgi\n\n\twsgi\n\tweb服务网关接口，一套基于socket协议，底层实现了wsgi协议的模块wsgiref\n\n\t路由系统\n\tindex\t正则\t反向解析\n\n\n\t视图\n\tFBV\tFunction base view 基于函数写的视图\n\tCBV\tClass base view\t基于类写的视图\n\n\t请求相关的数据都在request对象里\n\n\t响应相关：\n\t\thttpresponse（字符串/字节）\n\t\trender 内部调用httpresponse，然后渲染\n\t\tredirect\t重定向\n\n\tcsrf_token 工作原理\n\n\t\t客户端发送GET请求，返回给浏览器一个隐藏的随机字符串，用作下次POST请求的验证\n\t\t\n\t\t\n\n\tORM\n\n\t什么是orm？\n\n\t\t对象关系映射，models文件中有类 ==》表，字段==》列，对象==》行；\n\t\t开发者通过操作类和对象，内部通过orm转换成原生SQL语句然后去执行\n\t\t\n\torm与原生SQL的区别？\n\t\t本质是一样的，都是转换成SQL语句，只是语法不同\n\t\t而且原生SQL效率更快，\n\t\t但是orm开发效率更高，（因为不用写很长的SQL语句）\n\t\t兼容好，更换后端的数据库不用重新写代码，自动转换成新数据库的SQL语句\n\t\t\n\n\torm语句：\t\n\t\t\n\t\tcreate\n\t\tdelete\n\t\tupdate\n\t\t\n\t\tall\n\t\tfilter\n\t\texclude\t\t#排除，不是include（包含）\n\t\tvalues\n\t\tvalues_list\n\t\tget\n\t\tfirst\n\t\torder_by\n\t\tonly\t#只获取某列的数据，如果有不在某列的数据，会再做一次查询\n\t\tdefer\t#获取出了某列的数据\n\t\n=================================================\nGit\n\n\t基于 Git 做协同开发\n\t\n\t\tmaster/dev分支，然后每个人一个分支\n\t\t阶段性合并（1-2天，小功能开发完毕）\n\t\t\n\t临时遇到bug\n\t\n\t\t回滚\n\t\t\n\t\t创建bug分支\n\t\t\n\t代码review（检查）\n\t\n\t\t创建review分支\n\t\t\n\nVue:\n\n\t生命周期的钩子函数\n\t\n\t1.beforCreate\n\tdata对象赋值之前\n\t2.Created\n\tdata对象已经赋值，该进行的一些操作\n\t3.beforMount\n\t{{数据}}被渲染成为真正的数据\n\t4.Mounted\n\t{{数据}}被渲染成真正的数据执行的操作\n\tbeforUpdate \n\t数据更新之前做的一些操作 \n\tupdateddata\n\t数据更新完之后\n\tbeforDestory\n\t数据销毁之前的操作,执行的函数\n\tdestory\n\t数据销毁后执行的函数\n\t\n",[[1533976447351,["Administrator@Tielemao",[[-1,299,"节"]],[300,300],[299,299]]],[1533976449652,["Administrator@Tielemao",[[1,299,"件"]],[299,299],[300,300]]]],null,"Administrator@Tielemao"]]}