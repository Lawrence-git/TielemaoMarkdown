{"compress":true,"commitItems":[["858e3f98-b66b-4216-b7ae-83d9b88bf653",1530275556110,"",[[1530275547426,["Administrator@Tielemao",[[1,0,"# [Python 中的单例模式](https://segmentfault.com/a/1190000008141049)\n\n*   [![](https://sfault-avatar.b0.upaiyun.com/252/177/2521771040-54cb53b372821_small) python](https://segmentfault.com/t/python/blogs) \n\n_3_\n\n# 单例模式\n\n**单例模式（Singleton Pattern）**是一种常用的软件设计模式，该模式的主要目的是确保**某一个类只有一个实例存在**。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。\n\n比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。\n\n在 Python 中，我们可以用多种方法来实现单例模式：\n\n*   使用模块\n\n*   使用 `__new__`\n\n*   使用装饰器（decorator）\n\n*   使用元类（metaclass）\n\n# 使用模块\n\n其实，**Python 的模块就是天然的单例模式**，因为模块在第一次导入时，会生成 `.pyc` 文件，当第二次导入时，就会直接加载 `.pyc` 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：\n\n```\n# mysingleton.py\nclass My_Singleton(object):\n    def foo(self):\n        pass\n\nmy_singleton = My_Singleton()\n```\n\n将上面的代码保存在文件 `mysingleton.py` 中，然后这样使用：\n\n```\nfrom mysingleton import my_singleton\n\nmy_singleton.foo()\n```\n\n# 使用 `__new__`\n\n为了使类只能出现一个实例，我们可以使用 `__new__` 来控制实例的创建过程，代码如下：\n\n```\nclass Singleton(object):\n    _instance = None\n    def __new__(cls, *args, **kw):\n        if not cls._instance:\n            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)  \n        return cls._instance  \n\nclass MyClass(Singleton):  \n    a = 1\n```\n\n在上面的代码中，我们将类的实例和一个类变量 `_instance` 关联起来，如果 `cls._instance` 为 None 则创建实例，否则直接返回 `cls._instance`。\n\n执行情况如下：\n\n```\n>>> one = MyClass()\n>>> two = MyClass()\n>>> one == two\nTrue\n>>> one is two\nTrue\n>>> id(one), id(two)\n(4303862608, 4303862608)\n```\n\n# 使用装饰器\n\n我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：\n\n```\nfrom functools import wraps\n\ndef singleton(cls):\n    instances = {}\n    @wraps(cls)\n    def getinstance(*args, **kw):\n        if cls not in instances:\n            instances[cls] = cls(*args, **kw)\n        return instances[cls]\n    return getinstance\n\n@singleton\nclass MyClass(object):\n    a = 1\n```\n\n在上面，我们定义了一个装饰器 `singleton`，它返回了一个内部函数 `getinstance`，该函数会判断某个类是否在字典 `instances` 中，如果不存在，则会将 `cls` 作为 key，`cls(*args, **kw)` 作为 value 存到 `instances` 中，否则，直接返回 `instances[cls]`。\n\n# 使用 metaclass\n\n元类（metaclass）可以控制类的创建过程，它主要做三件事：\n\n*   拦截类的创建\n\n*   修改类的定义\n\n*   返回修改后的类\n\n使用元类实现单例模式的代码如下：\n\n```\nclass Singleton(type):\n    _instances = {}\n    def __call__(cls, *args, **kwargs):\n        if cls not in cls._instances:\n            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)\n        return cls._instances[cls]\n\n# Python2\nclass MyClass(object):\n    __metaclass__ = Singleton\n\n# Python3\n# class MyClass(metaclass=Singleton):\n#    pass\n```\n\n# 小结\n\n*   Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法"]],[0,0],[2693,2693]]],[1530275567662,["Administrator@Tielemao",[[-1,201,"_3_"]],[201,204],[201,201]]],[1530275568134,["Administrator@Tielemao",[[-1,202,"\n"]],[201,201],[200,200]]]]]]}