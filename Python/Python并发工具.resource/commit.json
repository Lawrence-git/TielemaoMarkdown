{"compress":true,"commitItems":[["e33cfce4-c140-422f-ad70-74666f12949c",1534426684197,"相信每一个接触Python并发的同学,刚开始都会有一段困惑时间:Python的并发看起来杂乱无章. 大家使用最多的是threading,但是,Python中由于GIL的存在,又没有实现真正的并发.因此, 在寻求其他并发工具的时候,Python往往由于资料太多,而大家又没有系统性的学习并发,导致 丈二的和尚摸不着头脑.\n\n本文将分别讲解Python中常用的几个并发工具：\n\n1.  线程\n2.  进程\n3.  线程池/进程池\n4.  并发执行框架\n5.  Python 3的asyncio\n6.  开源的gevent\n\n![snake](http://mingxinglai.com/cn/image/a-yellow-snake-pv.png)\n\n### 1\\. Python的threading库\n\nPython通过threading库提供了并发支持,有两种方式可以使用多线程:\n\n*   新建Thread对象\n*   继承Thread,然后实现run方法\n\nPython中的多线程使用示例:\n\n```\n#!/usr/bin/python\n#-*- coding: UTF-8 -*-\nimport os\nfrom threading import Thread\n\ndef get_data(num):\n    print('sum to {0} with pid {1}'.format(num, os.getpid()))\n    return sum([i for i in range(num)])\n\ndef main():\n    data = [ i for i in range(10) ]\n    threads = []\n    for num in data:\n        thread = Thread(target=get_data, args=(num,))\n        thread.start()\n        threads.append(thread)\n\n    for thread in threads:\n        thread.join()\n\nif __name__ == '__main__':\n    main()\n\n```\n\n### 2\\. Python的multiprocessing库\n\n> multiprocessing is a package that supports spawning processes using an API similar to the threading module.\n\n可以看到,为了让用户方便的使用多进程,减少用户代码的修改,multiprocessing的API与 threading的API是保持一致的.\n\n例如,对于上面这个并发的例子,只需要将导入语句修改为下面的语句,就能够正常使用多进程:\n\n```\nfrom multiprocessing import Process as Thread\n```\n\n当然,实际使用中不推荐大家`import Process as Thread`,这里只是为了说明,这两个包的接口 是一样的,很方便大家进行切换.\n\n### 3\\. 线程池/进程池\n\n我们知道,Python里面有一个内置的map函数,该函数是函数式编程语言里面的概念,也是 map-reduce中的map,它的作用就是对一个序列中的每一个元素进行某种操作,例如,求整数的平方:\n\n```\nmap(lambda x: x*x, [ i for i in range(5))\n```\n\n内置的map是单线程运行的,如果涉及到网络请求或者大量的cpu计算,则速度相对会慢很多,因此, 出现了并发的map,如下所示：\n\n```\nimport requests\nfrom multiprocessing import Pool\n\ndef get_website_data(url):\n    r = requests.get(url)\n    return r.url\n\ndef main():\n    urls = ['http://mingxinglai.com',\n            'http://www.baidu.com',\n            'http://163.com']\n    pool = Pool(2)\n    print pool.map(get_website_data, urls)\n\nmain()\n```\n\n为了与线程兼容,该模块还提供了multiprocessing.dummy,用以提供线程实现,如下所示：\n\n```\nfrom multiprocessing.dummy import Pool\n```\n\n### 4\\. 并发执行框架\n\n用过java的同学应该知道,java中有ThreadPoolExecutor框架,这类框架特别适合执行一些大批量 的异步任务.\n\nPython3的concurrent.futures模块,提供了Executor框架,类似于java中的ThreadPoolExecutor, 不过,Python中支持两种Executor,分别是：\n\n*   ThreadPoolExecutor\n*   ProcessPoolExecutor\n\n示例如下:\n\n```\nimport concurrent.futures\nimport math\n\nPRIMES = [\n    112272535095293,\n    112582705942171,\n    112272535095293,\n    115280095190773,\n    115797848077099,\n    1099726899285419]\n\ndef is_prime(n):\n    if n % 2 == 0:\n        return False\n\n    sqrt_n = int(math.floor(math.sqrt(n)))\n    for i in range(3, sqrt_n + 1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef main():\n    with concurrent.futures.ProcessPoolExecutor() as executor:\n        for number, prime in zip(PRIMES, executor.map(is_prime, PRIMES)):\n            print('%d is prime: %s' % (number, prime))\n\nif __name__ == '__main__':\n    main()\n```\n\n如果要使用ThreadPoolExecutor,只需要修改一行代码即可：\n\n```\nwith ThreadPoolExecutor(max_workers=1) as executor:\n```\n\n### 5\\. asyncio\n\nPython 3.4 中asyncio被纳入了标准库,它提供了使用协程编写单线程并发代码,通过IO多路复用 技术访问套接字和其他资源,Python 3.5中添加了async和awit这两个关键字.自此,协程成为新的 语法,而不再是一种生成器类型.\n\n```\nimport asyncio\n\nasync def slow_operation(n):\n    await asyncio.sleep(1)\n    print('Slow operation {} complete'.format(n))\n\nasync def main():\n    await asyncio.wait([\n        slow_operation(1),\n        slow_operation(2),\n        slow_operation(3),\n        ])\n\nloop = asyncio.get_event_loop()\nloop.run_until_complete(main())\n```\n\n### 6\\. gevent\n\ngevent是一个基于微线程库greenlet的并发框架,其基本思想是：当一个greenlet遇到IO操作时, 比如访问网络,就自动切换到其他的greenlet,等到IO操作完成,再在适当的时候切换回来继续执行. 由于IO操作非常耗时,经常使程序处于等待状态,有了gevent为我们自动切换协程,就保证总有 greenlet在运行,而不是等待IO.\n\n虽然与直接使用greenlet、eventlet相比性能略低,但是,它提供了和线程模型编程相仿的接口, 而且提供了Monkey Patch方法,可以在运行时动态修改标准库里大部分的阻塞式系统调用, 如socket, threading, select等模块.\n\ngevent的好处是Python 2和Python 3都可以使用,不像asyncio只能在python 3中使用.Gevent的使用示例如下:\n\n```\nimport gevent\n\ndef foo():\n    print('Running in foo')\n    gevent.sleep(0)\n    print('Explicit context switch to foo again')\n\ndef bar():\n    print('Explicit context to bar')\n    gevent.sleep(0)\n    print('Implicit context switch back to bar')\n\ngevent.joinall([\n    gevent.spawn(foo),\n    gevent.spawn(bar),\n])\n```\n\n**再强调一遍:** 当一个greenlet遇到IO操作时,比如访问网络,就自动切换到其他的greenlet, 等到IO操作完成,再在适当的时候切换回来继续执行.由于IO操作非常耗时,经常使程序处于等待 状态,有了gevent为我们自动切换协程,就保证总有greenlet在运行,而不是等待IO.\n\n所以上段代码的执行流程如下：\n\n![flow](http://mingxinglai.com/cn/image/python_concurrent_flow.gif)\n\n### 总结\n\n本文概要的介绍了Python中的6个并发工具,大家可以通过本文,快速的了解各个工具的使用,选择 适合的工作.\n\n[赖明星](http://mingxinglai.com/cn) / 2016-09-19",[[1534426665170,["Administrator@Tielemao",[[1,0,"\n"]],[0,0],[1,1]]],[1534426667225,["Administrator@Tielemao",[[1,0,"\n"]],[0,0],[1,1]]],[1534426672673,["Administrator@Tielemao",[[1,0,"Python并发工具"]],[0,0],[10,10]]],[1534426676640,["Administrator@Tielemao",[[1,0,"# "]],[0,0],[2,2]]]],null,"Administrator@Tielemao"]]}